## 3장 애그리거트 

주문 애그리거트는 다음을 포함한다.
- 총 금액인 totalAmounts를 갖고 있는 Order 엔티티 (루트 앤티티)
- 개별 구매 상품의 개수인 quantity와 금액인 price를 갖고 있는 Orderline 밸류

애그리거트는 복잡한 모델을 관리하는 기준을 준다. <br>
애그리거트에 속한 구성요소는 보통 라이프사이클을 함께한다. <br>
즉, 하나의 애그리거트에 속하려면 create(생성시점), update(변경시점), subject(변경주체)가 일치한다. <br>
언뜻 생각하면, prooduct 하위에 review가 존재한다 생각할 수 있지만 이 둘은 다른 애그리거트에 속한다. <br>
<br>
실무에서 2개 이상의 엔티티를 가지는 애그리거트는 드물다. <br>
<br>
애그리거트에 속한 모든 객체는 정상상태를 가져야한다.
애그리거트의 일관성 유지 : 애그리거트 루트의 핵심 역할  <br>
애그리거트의 루트 앤티티는 애그리거트의 대표 엔티티로, 애그리거트 전체를 관리한다. <br>
-> Order를 위한 리포지토리만 존재한다. OrderLines리포지토리 등은 별도 존재x <br>
한 트랜잭션에서는 한 개의 애그리거트만 수정하는 게 좋다.(트랜잭션의 범위는 작을 수록 좋다.) <br>

![img_1.png](img_1.png)

애그리거트는 다른 애그리거트를 참조할 수 있다. <br>
애그리거트 간의 참조는 필드(@ManyToOne, @OneToOne 활용)를 통해 쉽게 구현할 수 있다. <br>
그러나 필드를 통한 애그리거트 참조는 다음 문제를 야기할 수 있다.<br>
- 편한 탐색 오용
- 성능에 대한 고민
- 확장 어려움
ID(findById메서드)를 이용해 다른 애그리거트를 참조하면 이 세 문제를 완화시킬 수 있다.<br>
<br>

다른 애그리거트를 ID로 참조하면 조회속도가 문제될 수 있다. <br>
애그리거트마다 서로 다른 저장소를 사용하는 경우에는 한 번의 쿼리로 관련 애그리거트를 조회할 수 없다.<br>
이런 경우 조회 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성한다. <br>
이 방법은 코드가 복잡해지는 단점이 있지만 시스템의 처리량을 높일 수 있다는 장점이 있다. <br>
<br>
애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해보자. <br>
